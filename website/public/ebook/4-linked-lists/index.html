<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:100%/1.625 -apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:normal;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}h1{margin-left:0;margin-right:0;margin-top:2.4375rem;padding-bottom:calc(0.40625rem - 1px);padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.21875rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:2rem;line-height:1.1;border-bottom:1px solid hsla(0,0%,0%,0.07);}h2{margin-left:0;margin-right:0;margin-top:1.625rem;padding-bottom:calc(0.40625rem - 1px);padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.40625rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:1.51572rem;line-height:1.1;border-bottom:1px solid hsla(0,0%,0%,0.07);}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:1.31951rem;line-height:1.1;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.1;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:0.87055rem;line-height:1.1;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:hsla(0,0%,0%,0.53);font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:0.81225rem;line-height:1.1;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}ul{margin-left:1.625rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.625rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;font-size:0.85rem;line-height:1.625rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;font-size:1rem;line-height:1.625rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}blockquote{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:calc(0.8125rem - 1px);padding-right:0;padding-top:0;margin-bottom:0.8125rem;border-left:4px solid hsla(0,0%,0%,0.13);color:hsla(0,0%,0%,0.53);}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(0.8125rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}b{font-weight:600;}strong{font-weight:600;}dt{font-weight:600;}th{font-weight:600;}li{margin-bottom:calc(0.8125rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.625rem;margin-bottom:calc(0.8125rem / 2);margin-top:calc(0.8125rem / 2);}li > ul{margin-left:1.625rem;margin-bottom:calc(0.8125rem / 2);margin-top:calc(0.8125rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(0.8125rem / 2);}code{font-size:0.85rem;line-height:1.625rem;}kbd{font-size:0.85rem;line-height:1.625rem;}samp{font-size:0.85rem;line-height:1.625rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:1.08333rem;padding-right:1.08333rem;padding-top:0.8125rem;padding-bottom:calc(0.8125rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}h3,h4,h5,h6{margin-bottom:0.8125rem;margin-top:1.625rem;}ol,ul{margin-left:2.03125rem;}li>ol,li>ul{margin-left:2.03125rem;}a{color:#4078c0;text-decoration:none;}a:hover,a:active{text-decoration:underline;}ol, ul{margin-left:16px;}</style><link rel="manifest" href="/manifest.webmanifest"/><title data-react-helmet="true">4. Linked Lists | Another C Library</title><meta data-react-helmet="true" name="description" content="Another C Library rebuilds, and in some cases, improves upon, some of the most useful Computer Science algorithms from the ground up for engineers to build complex, scalable applications."/><meta data-react-helmet="true" property="og:title" content="4. Linked Lists"/><meta data-react-helmet="true" property="og:description" content="Another C Library rebuilds, and in some cases, improves upon, some of the most useful Computer Science algorithms from the ground up for engineers to build complex, scalable applications."/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="Daniel Curtis"/><meta data-react-helmet="true" name="twitter:title" content="4. Linked Lists"/><meta data-react-helmet="true" name="twitter:description" content="Another C Library rebuilds, and in some cases, improves upon, some of the most useful Computer Science algorithms from the ground up for engineers to build complex, scalable applications."/><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><style type="text/css">
    .anchor {
      float: left;
      padding-right: 4px;
      margin-left: -20px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var offset = element.offsetTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="shortcut icon" href="/icons/icon-48x48.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><meta name="generator" content="Gatsby 2.18.14"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=e7dae36d9f0cebf3ec80080daa0bd528"/><style data-href="/styles.66212a8dc2aa02e99aac.css">code[class*=language-],pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}html{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif`}a{text-decoration:none;cursor:pointer;color:#3182ce}a:hover{text-decoration:none;-webkit-filter:brightness(80%);filter:brightness(80%)}a:hover,button:hover{-webkit-transition:.6s;transition:.6s}button:hover{-webkit-filter:brightness(115%);filter:brightness(115%)}nav{display:flex;align-items:center}li{margin-bottom:3px}:not(pre)>code[class*=language],pre[class*=language]{border-radius:0;background:#f6f8fa;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;text-shadow:none}:not(pre)>code[class*=language]{color:#000;padding:3px}code[class*=language-],pre,pre[class*=language-]{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;text-shadow:none}pre{background:#f6f8fa;font-size:.85rem;line-height:32px;overflow:scroll}.Footer{max-width:1200px;margin:30px auto;display:flex;justify-content:space-between}.Flex{display:grid;grid-template-columns:auto auto;grid-column-gap:50px}.Content{max-width:950px;width:72vw}@media only screen and (max-width:600px){.Footer,nav{flex-direction:column}.Flex{grid-template-columns:auto}.Sidebar{display:none}.Content{width:100%}}.Index-mn{max-width:1200px;margin:80px auto;padding:10px}.Index-hr{background-color:#2d3748;height:50vh;display:flex;align-items:center;text-align:center;margin:0 auto}.Index-h2{font-size:calc(16px + 2vw);margin:0 auto;color:#fff;border-bottom:none}.Index-h3{font-size:calc(16px + 1vw);color:#e2e8f0}.Index-p{color:#1a202c;list-style:none}.Index-hr-txt{text-align:center;margin:0 auto}.Index-cd{font-size:calc(16px + 1.5vw);background-color:#4a5568;padding:5px}.Index-btn{border-radius:10px;border:none;padding:10px 24px;margin:10px;font-size:18px;background:#3182ce;color:#fff;cursor:pointer}.Md-mn{margin:0 auto;max-width:1200px;display:flex}.Md-cntnt{color:#000;margin:0;padding:20px}.Md-actv-lnk{color:#38a169;font-weight:700}.Md-pst-ftr{display:flex;justify-content:space-between;border-top:1px solid #000;padding-top:10px}.Md-rrw{padding-top:5px}.Ebook-mn{margin:0 auto;max-width:1200px;display:flex}.Ebook-cntnt{color:#000;margin:0;padding:20px}.Ebook-sdbr{background:#f7fafc;width:20vw;height:100vh;padding:15px;color:#63b3ed;position:-webkit-sticky;position:sticky;top:62px}.License-mn{margin:0 auto;max-width:1200px;min-height:60vh;padding:50px 10px}.Footer-ctr{background-color:#1a202c;padding:10px;color:#fff}.Footer-ul{list-style:none;margin-left:0}.Footer-lnk{color:#3182ce}.Footer-p{margin-bottom:15px}</style><link as="script" rel="preload" href="/app-2a558a725b94d45b6c02.js"/><link as="script" rel="preload" href="/component---src-templates-md-page-js-203a2af8ece2db94eba8.js"/><link as="script" rel="preload" href="/styles-a8f8354e20700922ebe9.js"/><link as="script" rel="preload" href="/commons-091d252790abf7509c25.js"/><link as="script" rel="preload" href="/webpack-runtime-0ce17398fc543280a4bc.js"/><link as="fetch" rel="preload" href="/page-data/ebook/4-linked-lists/page-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div style="background-color:white"><header style="position:sticky;top:0;background-color:#1A202C;z-index:1;color:white"><nav style="margin:auto;max-width:1200px"><a style="font-size:1.25rem;padding:1rem 1.5rem;font-family:-apple-system,&#x27;BlinkMacSystemFont&#x27;,&#x27;Segoe UI&#x27;,&#x27;Roboto&#x27;,&#x27;Oxygen&#x27;,&#x27;Ubuntu&#x27;,&#x27;Cantarell&#x27;,&#x27;Fira Sans&#x27;,&#x27;Droid Sans&#x27;,&#x27;Helvetica Neue&#x27;,sans-serif" href="/"><span style="font-weight:700">Another C Library</span></a><a style="font-size:1.25rem;padding:1rem 1.5rem;font-family:-apple-system,&#x27;BlinkMacSystemFont&#x27;,&#x27;Segoe UI&#x27;,&#x27;Roboto&#x27;,&#x27;Oxygen&#x27;,&#x27;Ubuntu&#x27;,&#x27;Cantarell&#x27;,&#x27;Fira Sans&#x27;,&#x27;Droid Sans&#x27;,&#x27;Helvetica Neue&#x27;,sans-serif" href="/docs/">Documentation</a><a style="font-size:1.25rem;padding:1rem 1.5rem;font-family:-apple-system,&#x27;BlinkMacSystemFont&#x27;,&#x27;Segoe UI&#x27;,&#x27;Roboto&#x27;,&#x27;Oxygen&#x27;,&#x27;Ubuntu&#x27;,&#x27;Cantarell&#x27;,&#x27;Fira Sans&#x27;,&#x27;Droid Sans&#x27;,&#x27;Helvetica Neue&#x27;,sans-serif;color:#38A169;border-bottom:solid 4px #2F855A;background-color:#2D3748" class="" href="/ebook/">Learn C</a><a style="font-size:1.25rem;padding:1rem 1.5rem;font-family:-apple-system,&#x27;BlinkMacSystemFont&#x27;,&#x27;Segoe UI&#x27;,&#x27;Roboto&#x27;,&#x27;Oxygen&#x27;,&#x27;Ubuntu&#x27;,&#x27;Cantarell&#x27;,&#x27;Fira Sans&#x27;,&#x27;Droid Sans&#x27;,&#x27;Helvetica Neue&#x27;,sans-serif" target="_blank" rel="noopener noreferrer" href="https://github.com/contactandyc/another-c-library">Github <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 576 512" style="padding-top:5px" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M576 24v127.984c0 21.461-25.96 31.98-40.971 16.971l-35.707-35.709-243.523 243.523c-9.373 9.373-24.568 9.373-33.941 0l-22.627-22.627c-9.373-9.373-9.373-24.569 0-33.941L442.756 76.676l-35.703-35.705C391.982 25.9 402.656 0 424.024 0H552c13.255 0 24 10.745 24 24zM407.029 270.794l-16 16A23.999 23.999 0 0 0 384 303.765V448H64V128h264a24.003 24.003 0 0 0 16.97-7.029l16-16C376.089 89.851 365.381 64 344 64H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V287.764c0-21.382-25.852-32.09-40.971-16.97z"></path></svg></a><p style="margin:auto">Version 1.0</p></nav></header><main><div class="Md-mn"><div class="Md-cntnt Content"><h1>4. Linked Lists</h1><p>Copyright <!-- -->2020<!-- --> Andy Curtis &amp; Daniel Curtis</p><div><h2 id="a-data-structure-interface"><a href="#a-data-structure-interface" aria-label="a data structure interface permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A data structure interface</h2>
<p>We will explore the singly linked list, the doubly linked list, binary search trees, and finally, the red-black tree.  Each of these builds upon each other in complexity and can share a similar interface.  The code and interfaces are meant more for understanding and to show various optimizations along the way.  A linked list and binary search trees allow for inserting, finding, erasing, and iteration.</p>
<p>This code that follows is found in illustrations/linked<em>structures/1</em>singly<em>linked</em>list<br/>
If you change to that directory, you will find the following Makefile.  </p>
<div class="gatsby-highlight" data-language="makefile"><pre class="language-makefile"><code class="language-makefile">DATA_STRUCTURE<span class="token operator">=</span>singly_linked_list

<span class="token symbol">all</span><span class="token punctuation">:</span> test_data_structure examples

<span class="token symbol">test_data_structure</span><span class="token punctuation">:</span> test_data_structure.c data_structure.h <span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>.c
	gcc test_data_structure.c <span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>.c -o test_data_structure -DDATA_STRUCTURE<span class="token operator">=</span>\"<span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>\"

<span class="token symbol">examples</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>./test_data_structure AB CAB ABCDEF AFCEDB

<span class="token symbol">clean</span><span class="token punctuation">:</span>
	rm -f test_data_structure *~</code></pre></div>
<p>When you run</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">make</code></pre></div>
<p>The first block with a colon will be run.  In this Makefile, it is the following line.</p>
<div class="gatsby-highlight" data-language="makefile"><pre class="language-makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> test_data_structure examples</code></pre></div>
<p>The all group simply refers to other groups to be built.  In this case, it is test<em>data</em>structure and examples.</p>
<div class="gatsby-highlight" data-language="makefile"><pre class="language-makefile"><code class="language-makefile"><span class="token symbol">test_data_structure</span><span class="token punctuation">:</span> test_data_structure.c data_structure.h <span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>.c
	gcc test_data_structure.c <span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>.c -o test_data_structure -DDATA_STRUCTURE<span class="token operator">=</span>\"<span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>\"

<span class="token symbol">examples</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>./test_data_structure AB CAB ABCDEF AFCEDB</code></pre></div>
<p>The lines of code after test<em>data</em>structure will run if the file called test<em>data</em>structure is older than the files after the colon.  If you edit test<em>data</em>structure.c, data<em>structure.h or singly</em>linked<em>list.h (same as $(DATA</em>STRUCTURE).h), the program will be built using the following line of code.  $(DATA<em>STRUCTURE) is converted to singly</em>linked<em>list.  The output is test</em>data_structure.</p>
<div class="gatsby-highlight" data-language="makefile"><pre class="language-makefile"><code class="language-makefile">gcc test_data_structure.c <span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>.c -o test_data_structure -DDATA_STRUCTURE<span class="token operator">=</span>\"<span class="token variable">$</span><span class="token punctuation">(</span>DATA_STRUCTURE<span class="token punctuation">)</span>\"</code></pre></div>
<p>If you didn't want to use a Makefile to build test<em>data</em>structure, you could do so from the command line using the following command.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">gcc test_data_structure.c singly_linked_list.c -o test_data_structure -DDATA_STRUCTURE=\&quot;singly_linked_list\&quot;</code></pre></div>
<p>The examples block will run every time because it doesn't have any dependencies, and examples isn't a file that exists.  If you were to create a file called examples, then the examples block would cease to run.  The @ symbol prevents the command from being printed to the screen.  By running <b>make</b>, you will effectively build test<em>data</em>structure if it needs to build and run the examples block.  Running <b>make clean</b> will clean up the binary.  You can run any block by specifying it.  <b>make all</b> is equivalent to running <b>make</b> as <b>make</b> runs the first block.  If you just want to run the examples block, you can by running <b>make examples</b>.  </p>
<p>Go ahead and read the code in illustrations/3<em>linked</em>structures/1<em>singly</em>linked_list and then continue with this book.  The code is inlined in the book as well, but it never hurts to read code and try and understand it.  To illustrate how red-black trees work, it makes sense to understand linked lists and binary search trees well first.  A great way to understand code is to have something which you can build, change, and experiment with.  This first example is a bit more involved than the typical hello world program.  However, it provides the basis for understanding more complicated work and is about as simple as I can make it.</p>
<p>If you run <code class="language-text">make</code>, you will get the following output.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ make
gcc test_data_structure.c singly_linked_list.c -o test_data_structure -DDATA_STRUCTURE=\&quot;singly_linked_list\&quot;
Creating singly_linked_list for AB
root -&gt; B -&gt; A -&gt; NULL
print_using_iteration: BA

Creating singly_linked_list for CAB
root -&gt; B -&gt; A -&gt; C -&gt; NULL
print_using_iteration: BAC

Creating singly_linked_list for ABCDEF
root -&gt; F -&gt; E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; NULL
print_using_iteration: FEDCBA

Creating singly_linked_list for AFCEDB
root -&gt; B -&gt; D -&gt; E -&gt; C -&gt; F -&gt; A -&gt; NULL
print_using_iteration: BDECFA</code></pre></div>
<p>After the code is built, <b>./test<em>data</em>structure AB CAB ABCDEF AFCEDB</b> is run, which creates four linked lists based upon the arguments passed in.  The output shows how the input transforms into a linked list with arrows (->) for pointers and letters for each node.  The linked lists will place the items in reverse order (notice that BA becomes root -> A -> B -> NULL).  root is just a pointer and not a node.  For your data structure to be accessible, you must have a reference to it.  NULL is to indicate that B doesn't point to a node.  This doesn't have to be the case. However, to show off linked lists, it is good to know the two instruction insertion method, which is demonstrated below.  </p>
<p>The primary goal is to build a red-black tree with an interface that looks something like the following (it'll change once we address production concerns).  The data<em>structure.h is an interface that can be used for singly-linked lists, doubly linked lists, binary search trees, and the red-black tree.  The interface or header file below separates the implementation from the definition.  The definition is the only thing that test</em>data_structure.c (later) will be able to work with.  When building larger software packages, defining clean interfaces can greatly reduce complexity.</p>
<p>data_structure.h</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _data_structure_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _data_structure_H</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"ac_common.h"</span></span>

<span class="token keyword">struct</span> <span class="token class-name">node_s</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node_s</span> node_t<span class="token punctuation">;</span>

<span class="token comment">/*
  You may or may not want to have methods like node_init, node_key, node_print,
  and node_destroy.  My purpose in having them is to provide a uniform interface
  for test_data_structure.  This is only an interface for testing.
*/</span>
node_t <span class="token operator">*</span><span class="token function">node_init</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">node_destroy</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token function">node_key</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">node_print</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
  Given a data structure, find a node given a pointer to the root node and the key of interest.
*/</span>
node_t <span class="token operator">*</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">,</span> node_t <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
  If the key doesn't exist, insert a node into the data structure.  The
  node_to_insert has already been initialized by the client application (most likely through node_init).  The node's physical location in memory will not change as a result of inserting or erasing nodes.  Because the root might change, a pointer to the root is passed to node_insert.
*/</span>
bool <span class="token function">node_insert</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_insert<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
  Once finding a node, erase the node from the data structure.  The
  node_to_erase is typically found through node_find.  The pointer to root is passed to node_erase as the root might change.  node_erase doesn't free resources used by node_to_erase.  It only unlinks it from the data structure.
*/</span>
bool <span class="token function">node_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_erase<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* Iteration
  All of the linked structures will support first and next.
  Some can support last and previous as well.
*/</span>
bool <span class="token function">node_previous_supported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
node_t <span class="token operator">*</span><span class="token function">node_first</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
node_t <span class="token operator">*</span><span class="token function">node_last</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
node_t <span class="token operator">*</span><span class="token function">node_next</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
node_t <span class="token operator">*</span><span class="token function">node_previous</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
  To destroy a data structure, you will need to use the following pattern...
  node_t *n = node_first_to_erase(root);
  while(n) {
    node_t *next = node_next_to_erase(n);
    node_destroy(n);
    n = next;
  }

  Notice that a temporary link to the next node to erase is saved before destroying the node.  For binary search trees, the beginning to the end isn't the same as a sorted order.  It's known as postorder iteration.  Postorder iteration can be useful for fast construction and destruction of binary search trees.  By having an alternate iterator for destruction, we can have
  one interface which works for several data structure types.
*/</span>
node_t <span class="token operator">*</span><span class="token function">node_first_to_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
node_t <span class="token operator">*</span><span class="token function">node_next_to_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span></code></pre></div>
<p>In C, you can specify a struct without indicating how it is defined in a header file.  The details can either be hidden in the implementation or declared later.  By declaring the structure in this way, outside applications won't be able to access members of the struct.  I generally try and hide implementation details, providing a minimalistic interface.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node_s</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node_s</span> node_t<span class="token punctuation">;</span></code></pre></div>
<p>The rest of the functions were commented inline above.</p>
<h2 id="the-data-structure-interface-test-driver"><a href="#the-data-structure-interface-test-driver" aria-label="the data structure interface test driver permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The data structure interface test driver</h2>
<p>In addition to having a common interface, I have created a set of functions to test the data structure.  The set of functions will include data_structure.h and test that the code is doing what it is supposed to do and show how to use the interface.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"data_structure.h"</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token comment">/*
  arg contains several characters (or letters).  Each letter is inserted
  into the data structure, assuming that it hasn't already been inserted.
  The characters are inserted in the order that they are found within the string.  Because this is a tool to test the data structure, I also test that if an insert should work, that it does work.  Once the insert succeeds, test if the item can be found.  After all of the inserts are done, the root of the data structure is returned.
*/</span>
node_t <span class="token operator">*</span><span class="token function">fill_data_structure</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> arg<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">node_init</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_insert</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Find failed for %c and insert failed as well!\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Find failed for %c after insert succeeded!\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    s<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  This function is similar to fill_data_structure, except that the characters
  are inserted in random order.
*/</span>
node_t <span class="token operator">*</span><span class="token function">fill_data_structure_randomly</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> arg<span class="token punctuation">;</span>
  <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> num_inserted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>num_inserted <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> len<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> p<span class="token operator">+</span>pos<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">node_init</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_insert</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Find failed for %c and insert failed as well!\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      num_inserted<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Find failed for %c after insert succeeded!\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  find_everything checks that every character in arg is properly inserted in the data structure.
*/</span>
<span class="token keyword">void</span> <span class="token function">find_everything</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> arg<span class="token punctuation">;</span> <span class="token comment">// check that everything can still be found</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Find failed for %c after binary tree was constructed!\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    s<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  find_and_erase_everything iterates over all of the characters in arg in random order and erases them.  erase should succeed if find succeeds.  If it doesn't, an error is printed.
*/</span>
<span class="token keyword">void</span> <span class="token function">find_and_erase_everything</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> arg<span class="token punctuation">;</span> <span class="token comment">// find and erase all of the nodes</span>
  <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> num_destroyed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>num_destroyed <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> len<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> p<span class="token operator">+</span>pos<span class="token punctuation">;</span>
    node_t <span class="token operator">*</span>node_to_erase <span class="token operator">=</span> <span class="token function">node_find</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node_to_erase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">node_erase</span><span class="token punctuation">(</span>node_to_erase<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Erase failed for %c after find succeeded!\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      num_destroyed<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token function">node_destroy</span><span class="token punctuation">(</span>node_to_erase<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  print the datastructure iterating over the keys using first/next
*/</span>
<span class="token keyword">void</span> <span class="token function">print_using_iteration</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"print_using_iteration: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">node_first</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token function">node_key</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> <span class="token function">node_next</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  print the datastructure backwards iterating over the keys using last/previous
*/</span>
<span class="token keyword">void</span> <span class="token function">print_using_reverse_iteration</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"print_using_reverse_iteration: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">node_last</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token function">node_key</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> <span class="token function">node_previous</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  destroy the data structure by iterating over the keys using the
  first_to_erase/next_to_erase methods
*/</span>
<span class="token keyword">void</span> <span class="token function">destroy_using_iteration</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">node_first_to_erase</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node_t <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token function">node_next_to_erase</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">node_destroy</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
1.  Create the data structure N times (100000) using the letters that are found
    in arg.  Randomize the insertion and erase order.
2.  Create the data structure using the letters that are found in arg by
    inserting them in the order of the string.  Print the whole data structure
    using the overall print method and using iteration.
3.  Finally, destroy the structure by using the first_node_to_erase,
    node_next_to_erase methods (which may be defined to be the same as
    first/next)
*/</span>
<span class="token keyword">void</span> <span class="token function">test_data_structure</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Creating %s for %s\n"</span><span class="token punctuation">,</span> DATA_STRUCTURE<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  node_t <span class="token operator">*</span>root<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    root <span class="token operator">=</span> <span class="token function">fill_data_structure_randomly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// node_print(root);</span>
    <span class="token function">find_everything</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">find_and_erase_everything</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  root <span class="token operator">=</span> <span class="token function">fill_data_structure</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">node_print</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print_using_iteration</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">node_previous_supported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">print_using_reverse_iteration</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">destroy_using_iteration</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  The various tests will use A-Z, a-z, and 0-9 for valid keys
*/</span>
bool <span class="token function">valid_char</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">>=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  Create a copy of the input string (p) and only include valid characters (based upon valid_char above).  Also, check that each character is
  unique.  The wp is only updated and incremented if a character is new and is
  valid
*/</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">get_valid_characters</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>wp <span class="token operator">=</span> res<span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_char</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			s <span class="token operator">=</span> res<span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>s <span class="token operator">&lt;</span> wp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">==</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				s<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> wp<span class="token punctuation">)</span>
				<span class="token operator">*</span>wp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		p<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">*</span>wp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
  The main function expects to have two or more command-line arguments and calls
  the function test_data_structure with each argument (after extracting valid
  characters).  If there are less than two arguments, a usage statement is
  printed, and the program exits.  One useful tip from the code below is that in
  C or C++, you can chain a series of string constants together by just having spacing or a newline character separating the string constants.
*/</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"%s &lt;sequence of characters for tree> [sequence2] ..."</span>
            <span class="token string">" [sequenceN]\n"</span><span class="token punctuation">,</span>
            argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"  Constructs data structures and runs various tests on them.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">char</span> <span class="token operator">*</span>arg <span class="token operator">=</span> <span class="token function">get_valid_characters</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">test_data_structure</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>The code is commented above (it's a good idea to begin reading code from the
main function.</p>
<p>The include order is important.  If you place data<em>structure.h after the standard includes, you might mask an error where data</em>structure.h doesn't include all of its dependencies properly.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"data_structure.h"</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></code></pre></div>
<h2 id="the-singly-linked-list"><a href="#the-singly-linked-list" aria-label="the singly linked list permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The singly linked list</h2>
<p>In the previous section, we implemented a basic interface.  Below is the implementation of the singly-linked list.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"data_structure.h"</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token keyword">char</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

node_t <span class="token operator">*</span><span class="token function">node_init</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token punctuation">(</span>node_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">node_destroy</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">free</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token function">node_key</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>key<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">,</span> node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> root<span class="token operator">-></span>key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    root <span class="token operator">=</span> root<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">node_insert</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_insert<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_to_insert<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
  <span class="token operator">*</span>root <span class="token operator">=</span> node_to_insert<span class="token punctuation">;</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">node_print</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" -> %c"</span><span class="token punctuation">,</span> n<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" -> NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">node_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_erase<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> node_to_erase<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// no end of list check</span>
    prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// this will cause the program to crash if n is NULL (which is what we are doing anyways)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span>
    prev<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token operator">*</span>root <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_first</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_last</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_next</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">}</span>

bool <span class="token function">node_previous_supported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_previous</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_first_to_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_next_to_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>Singly-linked lists have a single link or pointer connecting one node to the next.  The pointer is often called next, but can be anything.  Because the structure is hidden inside the implementation, there are functions to initialize and destroy the object.  node_key is also needed to get the key member for the same reason.  </p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token keyword">char</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

node_t <span class="token operator">*</span><span class="token function">node_init</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token punctuation">(</span>node_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">node_destroy</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">free</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token function">node_key</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>key<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>Insertion into a singly linked list is a very fast operation typically requiring two lines of code.  1.  Associate the link on the node to insert it to the root node.  2.  Set the root node pointer to point to the node to insert.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_insert</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_insert<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_to_insert<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span> <span class="token comment">// line 1</span>
  <span class="token operator">*</span>root <span class="token operator">=</span> node_to_insert<span class="token punctuation">;</span>       <span class="token comment">// line 2</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Iterating through a linked list might look like the following:</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">iterate_through_linked_list</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>To iterate through a linked list looking for a particular match, you would do the following.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_find</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">,</span> node_t <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> root<span class="token operator">-></span>key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    root <span class="token operator">=</span> root<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>With lists, the root node is the first node.  With binary search trees, the first node is the left most node.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_first</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_next</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>For the singly linked list, going backward doesn't work, so node<em>previous</em>supported should return false and node_previous should return NULL</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_previous_supported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_previous</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>While singly linked lists can't go backward due to a lack of a previous pointer, you can keep track of the last node as you iterate through the list.  This can be useful for finding the last node in a list or erasing a node.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_last</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Erasing a node follows a similar approach to node_last, except the while(n) statement will also test to see if n matches the node to erase.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_erase<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&amp;&amp;</span> n <span class="token operator">!=</span> node_to_erase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre></div>
<p>Once the while loop has finished, if n is not NULL, then it must match the node<em>to</em>erase.  There are two conditions in the case that remain.  If prev is NULL, then the node to erase is at the head or root of the list.  In this case, link the root to the node that the current node to erase links to.  Otherwise, link the prev->next pointer to n's next pointer.  Finally, return true.  If n was NULL, then return false.  It is most likely that n will not be NULL (otherwise, we wouldn't have the node to erase in the first place).  Because of this, I choose to have this condition first.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">  <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span>
      prev<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
      <span class="token operator">*</span>root <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this should never happen!</span>
  <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>A slightly less performant approach where we test for n being NULL first reduces nesting.  I use both approaches in practice (and sometimes don't test for n at all).</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span>
    prev<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token operator">*</span>root <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>We could even consider implementing the code, assuming that node<em>to</em>erase must exist like the following.  Because I'm choosing to abort if n is NULL due to incorrect usage, the version below is what ultimately ended up in our code.  This code would abort if n was NULL anyways in the while loop if the node<em>to</em>erase didn't exist.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_erase<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> node_to_erase<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// no end of list check</span>
    prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// this will cause the program to crash if n is NULL (which is what we are doing anyways)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span>
    prev<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// this will cause a crash if n is not found</span>
  <span class="token keyword">else</span>
    <span class="token operator">*</span>root <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// this will cause a crash if n is not found</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Finally, it is fine for linked lists to use the first to last order for destroying the list.  node<em>first</em>to<em>erase and node</em>next<em>to</em>erase are similar to node<em>first and node</em>next respectively.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_first_to_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_next_to_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>Now that we are through the code, if you haven't done it, you can run <b>make</b> in illustrations/linked<em>structures/1</em>singly<em>linked</em>list.  The output should look like the following.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ make
gcc test_data_structure.c singly_linked_list.c -o test_data_structure -DDATA_STRUCTURE=\&quot;singly_linked_list\&quot;
Creating singly_linked_list for AB
root -&gt; B -&gt; A -&gt; NULL
print_using_iteration: BA

Creating singly_linked_list for CAB
root -&gt; B -&gt; A -&gt; C -&gt; NULL
print_using_iteration: BAC

Creating singly_linked_list for ABCDEF
root -&gt; F -&gt; E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; NULL
print_using_iteration: FEDCBA

Creating singly_linked_list for AFCEDB
root -&gt; B -&gt; D -&gt; E -&gt; C -&gt; F -&gt; A -&gt; NULL
print_using_iteration: BDECFA</code></pre></div>
<p>You might notice that the linked lists are reversed.  This is because we are using the two-line insert technique and putting items at the front of the list.  When using singly-linked lists, it is common to maintain a head (or root) and a tail pointer.  The tail refers to the last node or NULL if the list is empty.  By maintaining a tail, one can efficiently insert items at the end of the list.  If you don't maintain a tail and still wish to insert items at the end of the list, you can do that by skipping to the last node and then linking it to your new node from the last node.</p>
<h2 id="the-doubly-linked-list"><a href="#the-doubly-linked-list" aria-label="the doubly linked list permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The doubly linked list</h2>
<p>Doubly linked lists introduce link nodes in both directions.  A doubly linked list will have a next and a previous pointer (the naming is up to you).  For example, in the case of a doubly-linked list for B -> A -> C, the following would hold.  We will denote a link starting from a node with a - and the direction being > next or &#x3C; previous.  You can think of the linkage like the following illustrations.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">B -&gt; A, B -&lt; NULL (B links to A for next pointer and NULL for the previous pointer)
A -&gt; C, A -&lt; B (A links to C for next pointer and B for the previous pointer)
C -&gt; NULL, C -&lt; A (C links to NULL for next pointer and A for the previous pointer)</code></pre></div>
<p>Next pointers are the same as singly linked list.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">root -&gt; B -&gt; A -&gt; C -&gt; NULL</code></pre></div>
<p>Previous pointers are new.  Note that B (the root or head node) doesn't point back to the root pointer.  The root pointer is not a node.  It is just a way of remembering where the data structure lives in memory (as its a pointer to the first node).</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">NULL &lt;- B &lt;- A &lt;- C</code></pre></div>
<p>The full code for the doubly linked list is found in illustrations/linked<em>structures/2</em>doubly<em>linked</em>list.  The code is identical, with the following exceptions in doubly<em>linked</em>list.c (name changed from singly<em>linked</em>list.c) and the Makefile where the DATA<em>STRUCTURE constant changed to doubly</em>linked_list.</p>
<p>The node_s struct changes from</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token keyword">char</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>To the following to include a previous pointer.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_s</span> <span class="token operator">*</span>previous<span class="token punctuation">;</span>
  <span class="token keyword">char</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>The node<em>previous</em>supported and node_previous are changed from</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_previous_supported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_previous</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>To the following, because there is now a method for iterating through previous elements.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_previous_supported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span> <span class="token punctuation">}</span>

node_t <span class="token operator">*</span><span class="token function">node_previous</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token operator">-></span>previous<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>The node_init method needs to change from</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_init</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token punctuation">(</span>node_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>To the following to initialize the previous member.  It is possibly more efficient to assign multiple variables of the same type to a single value when you are able as I do in the <code class="language-text">n-&gt;next = n-&gt;previous = NULL;</code> line demonstrated below.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">node_t <span class="token operator">*</span><span class="token function">node_init</span><span class="token punctuation">(</span><span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token punctuation">(</span>node_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>previous <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  n<span class="token operator">-></span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>The insert method will change from</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_insert</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_insert<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_to_insert<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
  <span class="token operator">*</span>root <span class="token operator">=</span> node_to_insert<span class="token punctuation">;</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>To the following to initialize the previous pointer properly.  After the node<em>to</em>insert is added to the root or head, if there was a previous node at the root, then link that node's previous pointer to the node<em>to</em>insert.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_insert</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_insert<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_to_insert<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node_to_insert<span class="token operator">-></span>next<span class="token punctuation">)</span>
    node_to_insert<span class="token operator">-></span>next<span class="token operator">-></span>previous <span class="token operator">=</span> node_to_insert<span class="token punctuation">;</span>
  <span class="token operator">*</span>root <span class="token operator">=</span> node_to_insert<span class="token punctuation">;</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>The erase method will change from</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>node_to_erase<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> node_to_erase<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// no end of list check</span>
    prev <span class="token operator">=</span> n<span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// this will cause the program to crash if n is NULL (which is</span>
                 <span class="token comment">// what we are doing anyways)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">)</span>
    prev<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token operator">*</span>root <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>To the following because we don't need to find the node before the given node to erase the node.  The previous pointer already exists on the node, so we can unlink or erase the node from the data structure simply by relinking the nodes that are before (previous) and after (next) to the given node.  </p>
<p>If there is a previous node to the node to erase (n), then link the previous node's next pointer to the same value as n's next pointer.  If n's next pointer is not NULL, then link the next node's previous pointer to n's previous pointer.</p>
<p>If there is not a previous node to the node to erase (n), then the node that is being erased is the first node in the list.  Reset the root pointer to point the same value as n's next pointer.  If n has a non NULL next pointer (it isn't the only node in the list), then link the node that is pointed to by n's next pointer to NULL as the node that is pointed to by n's next pointer has become the new root or head of the list.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">bool <span class="token function">node_erase</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>n<span class="token punctuation">,</span> node_t <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-></span>previous<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n<span class="token operator">-></span>previous<span class="token operator">-></span>next <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-></span>next<span class="token punctuation">)</span>
      n<span class="token operator">-></span>next<span class="token operator">-></span>previous <span class="token operator">=</span> n<span class="token operator">-></span>previous<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>root <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-></span>next<span class="token punctuation">)</span>
      n<span class="token operator">-></span>next<span class="token operator">-></span>previous <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>The last function that changed is the node<em>print method.  node</em>print is changed to print two lines.  The first line is the same as the singly linked list in that it shows the next pointers.  The second line shows the previous pointers.  The second line prints only if the list is not empty.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">node_print</span><span class="token punctuation">(</span>node_t <span class="token operator">*</span>np<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node_t <span class="token operator">*</span>n <span class="token operator">=</span> np<span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" -> %c"</span><span class="token punctuation">,</span> n<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" -> NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>np<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n <span class="token operator">=</span> np<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" &lt;- %c"</span><span class="token punctuation">,</span> n<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      n <span class="token operator">=</span> n<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Next up is a brief explanation of threads, and then we will use what we've learned to create a very useful allocation object.  In this chapter, I began relaxing how much I'm explaining.  A very important skill is to learn to read code (regardless of how hard it is to read).  As this book progresses, there will be less in the way of explanations.</p>
<p><a href="../../../README.md">Table of Contents (only if viewing on Github)</a></p></div><div class="Md-pst-ftr"><a href="/ebook/11-balancing-binary-search-trees"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="Md-rrw" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M256 504C119 504 8 393 8 256S119 8 256 8s248 111 248 248-111 248-248 248zm116-292H256v-70.9c0-10.7-13-16.1-20.5-8.5L121.2 247.5c-4.7 4.7-4.7 12.2 0 16.9l114.3 114.9c7.6 7.6 20.5 2.2 20.5-8.5V300h116c6.6 0 12-5.4 12-12v-64c0-6.6-5.4-12-12-12z"></path></svg> <!-- -->11. Balancing Binary Search Trees</a><a href="/ebook/13-map">13. The Map Object<!-- --> <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="Md-rrw" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M256 8c137 0 248 111 248 248S393 504 256 504 8 393 8 256 119 8 256 8zM140 300h116v70.9c0 10.7 13 16.1 20.5 8.5l114.3-114.9c4.7-4.7 4.7-12.2 0-16.9l-114.3-115c-7.6-7.6-20.5-2.2-20.5 8.5V212H140c-6.6 0-12 5.4-12 12v64c0 6.6 5.4 12 12 12z"></path></svg></a></div></div><div style="font-family:-apple-system,&#x27;BlinkMacSystemFont&#x27;,&#x27;Segoe UI&#x27;,&#x27;Roboto&#x27;,&#x27;Oxygen&#x27;,
      &#x27;Ubuntu&#x27;,&#x27;Cantarell&#x27;,&#x27;Fira Sans&#x27;,&#x27;Droid Sans&#x27;,&#x27;Helvetica Neue&#x27;,sans-serif;height:100vh;padding:15px;color:#1E4E8C;position:sticky;top:62px;border-left:solid 1px #EDF2F7" class="Sidebar"><div><div><a href="/ebook/1-getting-started">1. Getting Started</a></div><div><a href="/ebook/2-timing">2. Timing Your Code (First Project)</a></div><div><a href="/ebook/3-buffer">3. The Buffer Object</a></div><div><a href="/ebook/4-linked-lists">4. Linked Lists</a><ul style="padding-left:0;list-style:none"><li style="margin-bottom:0"><a href="/ebook/4-linked-lists#a-data-structure-interface">A data structure interface</a></li><li style="margin-bottom:0"><a href="/ebook/4-linked-lists#the-data-structure-interface-test-driver">The data structure interface test driver</a></li><li style="margin-bottom:0"><a href="/ebook/4-linked-lists#the-singly-linked-list">The singly linked list</a></li><li style="margin-bottom:0"><a href="/ebook/4-linked-lists#the-doubly-linked-list">The doubly linked list</a></li></ul></div><div><a href="/ebook/5-threads">5. Threads</a></div><div><a href="/ebook/6-macros">6. Macros</a></div><div><a href="/ebook/7-allocator">7. The Global Allocator Object</a></div><div><a href="/ebook/8-allocator-implementation">8. The Global Allocator Implementation</a></div><div><a href="/ebook/9-pool">9. The Pool Object</a></div><div><a href="/ebook/10-binary-search-trees">10. Binary Search Trees</a></div><div><a href="/ebook/11-balancing-binary-search-trees">11. Balancing Binary Search Trees</a></div><div><a href="/ebook/12-red-black-tree">12. The Red-Black Tree</a></div><div><a href="/ebook/13-map">13. The Map Object</a></div><div><a href="/ebook/14-set-and-multimap">14. The Set and Multimap</a></div></div></div></div></main><footer class="Footer-ctr"><div class="Footer"><div><h1 style="margin:10px 0">Another C Library</h1><p class="Footer-p"> <!-- -->2020<!-- --> Andy Curtis &amp; Daniel Curtis</p><ul class="Footer-ul"><li><a class="Footer-lnk" href="/contact">Contact</a></li><li><a class="Footer-lnk" href="/contributing">Contributing</a></li><li><a class="Footer-lnk" href="/license">License</a></li></ul></div><div><h2 style="margin:10px auto">Learn C</h2><ul class="Footer-ul"><li><a href="/ebook/1-getting-started">1. Getting Started</a></li><li><a href="/ebook/2-timing">2. Timing Your Code (First Project)</a></li><li><a href="/ebook/3-buffer">3. The Buffer Object</a></li><li><a href="/ebook/4-linked-lists">4. Linked Lists</a></li><li><a href="/ebook/5-threads">5. Threads</a></li><li><a href="/ebook/6-macros">6. Macros</a></li><li><a href="/ebook/7-allocator">7. The Global Allocator Object</a></li><li><a href="/ebook/8-allocator-implementation">8. The Global Allocator Implementation</a></li><li><a href="/ebook/9-pool">9. The Pool Object</a></li><li><a href="/ebook/10-binary-search-trees">10. Binary Search Trees</a></li><li><a href="/ebook/11-balancing-binary-search-trees">11. Balancing Binary Search Trees</a></li><li><a href="/ebook/12-red-black-tree">12. The Red-Black Tree</a></li><li><a href="/ebook/13-map">13. The Map Object</a></li><li><a href="/ebook/14-set-and-multimap">14. The Set and Multimap</a></li></ul></div><div><div><h2 style="margin:10px auto">Documentation</h2><ul class="Footer-ul"><li><a href="/docs/ac-allocator">ac_allocator</a></li><li><a href="/docs/ac-pool">ac_pool</a></li></ul></div><h2 style="margin:10px auto">Resources</h2><ul class="Footer-ul"><li><a href="https://medium.com/software-design/why-software-developers-should-care-about-cpu-caches-8da04355bb8a" target="_blank" rel="noopener noreferrer" class="Footer-lnk">Why software developers should care about CPU caches <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 576 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M576 24v127.984c0 21.461-25.96 31.98-40.971 16.971l-35.707-35.709-243.523 243.523c-9.373 9.373-24.568 9.373-33.941 0l-22.627-22.627c-9.373-9.373-9.373-24.569 0-33.941L442.756 76.676l-35.703-35.705C391.982 25.9 402.656 0 424.024 0H552c13.255 0 24 10.745 24 24zM407.029 270.794l-16 16A23.999 23.999 0 0 0 384 303.765V448H64V128h264a24.003 24.003 0 0 0 16.97-7.029l16-16C376.089 89.851 365.381 64 344 64H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V287.764c0-21.382-25.852-32.09-40.971-16.97z"></path></svg></a></li><li><a href="https://github.com/contactandyc/another-c-library/blob/master/docs/tips.md#create-multiline-macro-in-c" target="_blank" rel="noopener noreferrer" class="Footer-lnk">Helpful Tips for Formatting <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 576 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M576 24v127.984c0 21.461-25.96 31.98-40.971 16.971l-35.707-35.709-243.523 243.523c-9.373 9.373-24.568 9.373-33.941 0l-22.627-22.627c-9.373-9.373-9.373-24.569 0-33.941L442.756 76.676l-35.703-35.705C391.982 25.9 402.656 0 424.024 0H552c13.255 0 24 10.745 24 24zM407.029 270.794l-16 16A23.999 23.999 0 0 0 384 303.765V448H64V128h264a24.003 24.003 0 0 0 16.97-7.029l16-16C376.089 89.851 365.381 64 344 64H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V287.764c0-21.382-25.852-32.09-40.971-16.97z"></path></svg></a></li><li><a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition" target="_blank" rel="noopener noreferrer" class="Footer-lnk">Introduction to Alogorithms <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 576 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M576 24v127.984c0 21.461-25.96 31.98-40.971 16.971l-35.707-35.709-243.523 243.523c-9.373 9.373-24.568 9.373-33.941 0l-22.627-22.627c-9.373-9.373-9.373-24.569 0-33.941L442.756 76.676l-35.703-35.705C391.982 25.9 402.656 0 424.024 0H552c13.255 0 24 10.745 24 24zM407.029 270.794l-16 16A23.999 23.999 0 0 0 384 303.765V448H64V128h264a24.003 24.003 0 0 0 16.97-7.029l16-16C376.089 89.851 365.381 64 344 64H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V287.764c0-21.382-25.852-32.09-40.971-16.97z"></path></svg></a></li></ul></div></div></footer></div></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-155680388-1', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/ebook/4-linked-lists/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-2a558a725b94d45b6c02.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-44b37c3d0621676eebb5.js"],"component---src-templates-md-page-js":["/component---src-templates-md-page-js-203a2af8ece2db94eba8.js"],"component---src-pages-404-js":["/component---src-pages-404-js-149358f39a4e91e4fd14.js"],"component---src-pages-cards-js":["/component---src-pages-cards-js-4f7f83b47ce15ad24484.js"],"component---src-pages-contact-js":["/component---src-pages-contact-js-dd1d616c946bf818cddf.js"],"component---src-pages-contributing-js":["/component---src-pages-contributing-js-c395ff2a88d6c0887a23.js"],"component---src-pages-docs-js":["/component---src-pages-docs-js-5e463a823fa0254492be.js"],"component---src-pages-ebook-js":["/component---src-pages-ebook-js-21f13dc773f52113d145.js"],"component---src-pages-index-js":["/component---src-pages-index-js-2129ae864aeb040afe4d.js"],"component---src-pages-license-js":["/component---src-pages-license-js-97064b9e0f17f63a1129.js"]};/*]]>*/</script><script src="/webpack-runtime-0ce17398fc543280a4bc.js" async=""></script><script src="/commons-091d252790abf7509c25.js" async=""></script><script src="/styles-a8f8354e20700922ebe9.js" async=""></script><script src="/component---src-templates-md-page-js-203a2af8ece2db94eba8.js" async=""></script><script src="/app-2a558a725b94d45b6c02.js" async=""></script></body></html>